# 프론트엔드 시스템 디자인
## 1. 브라우저 탭 레벨에서의 참여자 고려
💡 중요한 설계 결정사항:

같은 사용자가 여러 탭에서 같은 문서를 열 수 있음
각 탭을 별도의 참여자로 취급하는 게 단순함
탭 간 직접 통신이 없다고 가정

탭 간 동기화 전략

브라우저 스토리지 활용: localStorage 이벤트로 탭 간 상태 공유
BroadcastChannel API: 같은 origin의 탭들 간 실시간 메시징
SharedWorker: 탭들이 공유하는 백그라운드 스레드로 상태 관리
서버 중심 동기화: 각 탭이 독립적으로 서버와 통신하며 동기화

탭 식별 및 관리

고유 탭 ID: 각 탭마다 UUID 생성하여 구분
세션 관리: 탭이 닫히거나 새로고침될 때 상태 복구
커서 위치 추적: 사용자의 여러 탭에서 각각 다른 편집 위치 관리

## 2. 네트워크 지연시간이 핵심 문제
이상적인 상황: 통신이 즉시 이루어진다면
→ 단일 사용자 편집기 만들듯이 간단하게 구현 가능
현실: 네트워크 지연시간 존재
→ 복잡한 동기화 알고리즘 필요
지연시간 최적화 전략

Optimistic UI: 서버 응답을 기다리지 않고 즉시 UI 업데이트
배치 처리: 여러 작은 변경사항을 묶어서 한 번에 전송
압축 및 델타: 전체 문서가 아닌 변경 부분만 전송
CDN 활용: 지리적으로 가까운 엣지 서버 사용

네트워크 불안정 대응

재시도 로직: 실패한 요청에 대한 지수 백오프 재시도
연결 상태 감지: online/offline 이벤트 모니터링
큐 시스템: 오프라인 중 변경사항을 로컬에 저장 후 재연결시 동기화

1. WebSocket vs SSE 차이점 이해
📡 Server-Sent Events (SSE)
SSE 특징:

단방향 통신: 서버 → 클라이언트만 가능
HTTP 기반: 기존 웹 인프라 활용 가능
자동 재연결: 연결이 끊어지면 자동으로 재시도
간단한 구현: EventSource API로 쉽게 사용

장점: 구현 간단, 방화벽 친화적, 자동 재연결
단점: 단방향만 가능, 바이너리 데이터 전송 어려움
🔄 WebSocket
WebSocket 특징:

양방향 통신: 클라이언트 ↔ 서버 모두 가능
낮은 오버헤드: HTTP 헤더 없이 데이터만 전송
실시간성: 지연시간 최소화
바이너리 지원: 텍스트와 바이너리 모두 전송 가능

장점: 진정한 실시간, 양방향 통신, 낮은 지연시간
단점: 구현 복잡, 연결 관리 필요, 방화벽 이슈 가능
🤔 언제 무엇을 사용할까?
상황추천 기술이유읽기 전용 실시간 피드SSE단방향이면 충분, 구현 간단채팅 애플리케이션WebSocket양방향 통신 필수협업 문서 편집WebSocket실시간 편집 + 즉시 동기화주식 가격 피드SSE서버에서 클라이언트로만 전송
하이브리드 접근법

초기 연결: SSE로 시작해서 필요시 WebSocket으로 업그레이드
폴백 전략: WebSocket 실패시 SSE나 폴링으로 대체
프로토콜 협상: 클라이언트 환경에 따라 최적 프로토콜 선택

## 3. 간단한 충돌 감지 메커니즘
⚠️ 충돌이 발생하는 상황들

동시 편집: 두 사용자가 같은 위치를 동시에 편집
삭제 충돌: A가 텍스트를 삭제하는 동안 B가 같은 텍스트를 수정
순서 문제: 네트워크 지연으로 operation 순서가 뒤바뀜

기본 충돌 감지 방법
1. 타임스탬프 기반 감지

동시성 임계값: 100ms 이내 작업을 동시 편집으로 간주
논리적 시계: 서버 시간 기준으로 이벤트 순서 결정
벡터 클럭: 분산 환경에서 인과관계 추적

2. 위치 기반 충돌 감지

영역 겹침: 편집 범위가 겹치는지 계산
근접성 검사: 일정 거리 내 편집을 잠재적 충돌로 감지
문맥 분석: 단어나 문장 단위로 충돌 범위 확장

3. 버전 기반 감지

문서 버전: 각 변경마다 버전 번호 증가
기대 버전: 작업이 적용될 예상 버전과 실제 버전 비교
분기 감지: 같은 버전에서 여러 변경이 분기될 때

간단한 충돌 해결 전략
Last Write Wins (마지막 쓰기 우선)

구현 간단: 나중에 도착한 변경사항이 우선
사용자 경험: 일부 작업이 사라질 수 있음
적합한 경우: 실시간성이 중요하고 정확성이 덜 중요한 경우

First Come First Served (선착순)

순서 보장: 서버에 먼저 도착한 순서대로 적용
공정성: 모든 사용자가 동등한 기회
타임스탬프 의존: 정확한 시간 동기화 필요

User Priority (사용자 우선순위)

역할 기반: 편집자, 리뷰어, 관리자 등 역할에 따른 우선순위
경험 기반: 문서 작성자나 더 많이 기여한 사용자 우선
동적 조정: 상황에 따라 우선순위 변경

## 4. Operational Transformation (OT) 기초
핵심 개념
OT는 두 개의 동시 작업을 변환하여 최종 상태를 일관되게 만드는 알고리즘
기본 원리
초기 상태: "Hello"
사용자 A: 위치 2에 "XX" 삽입 → "HeXXllo"  
사용자 B: 위치 4에 "YY" 삽입 → "HellYYo"

문제: 각자 적용하면 다른 결과
해결: B의 작업을 A의 변경사항에 맞게 변환
OT의 장점과 단점
장점:

정확한 의도 보존
복잡한 편집 작업 지원
잘 정립된 수학적 기반

단점:

구현 복잡성
성능 오버헤드
디버깅 어려움

## 5. CRDT (Conflict-free Replicated Data Types) 기초
핵심 개념
CRDT는 분산 환경에서 충돌 없이 동기화되는 데이터 구조
CRDT vs OT 비교

OT: 충돌을 감지하고 변환으로 해결
CRDT: 충돌이 구조적으로 불가능하도록 설계

CRDT의 장점과 단점
장점:

수학적으로 충돌 불가능
네트워크 분할 내성
구현 상대적 단순

단점:

메모리 사용량 증가
일부 편집 패턴에서 비직관적 결과
가비지 컬렉션 복잡

실제 활용 라이브러리

Yjs: 가장 인기있는 JavaScript CRDT 라이브러리
Automerge: JSON 문서를 위한 CRDT
ShareJS: OT와 CRDT 모두 지원

## 6. 실시간 협업의 UX 고려사항
사용자 인식 (User Awareness)

커서 표시: 다른 사용자의 현재 편집 위치
사용자 목록: 현재 접속 중인 협업자들
활동 피드: 누가 언제 무엇을 수정했는지

시각적 피드백

실시간 하이라이트: 다른 사용자가 편집 중인 영역
색상 코딩: 사용자별 고유 색상으로 구분
애니메이션: 변경사항이 부드럽게 나타나도록

성능 최적화

가상화: 대용량 문서에서 보이는 부분만 렌더링
디바운싱: 빠른 타이핑 시 불필요한 업데이트 방지
배치 업데이트: 여러 변경사항을 한 번에 DOM에 적용

접근성 고려사항

스크린 리더: 협업 상황을 음성으로 안내
키보드 네비게이션: 마우스 없이도 모든 기능 사용 가능
고대비 모드: 시각 장애인을 위한 명확한 구분