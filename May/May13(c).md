# MCQ 한국어 - JavaScript, WebAPIs, CSS, HTML, Browser, Performance, I18n

## 1. 브라우저에서 cookie, `sessionStorage`, `localStorage`의 차이점을 설명하세요.
모두 클라이언트(사용자 브라우저)에 데이터를 저장하는 메커니즘입니다.
- 쿠키: 서버-클라이언트 통신에 적합, 작은 저장 용량, 영구적이거나 세션 기반 가능, 도메인별 제한
- `localStorage`: 장기 저장에 적합, 브라우저 종료 후에도 데이터 유지, 같은 출처의 모든 탭과 창에서 접근 가능, 세 가지 중 가장 큰 저장 용량
- `sessionStorage`: 단일 페이지 세션 내 임시 데이터에 적합, 탭이나 창이 닫히면 데이터 삭제, 쿠키보다 큰 저장 용량

## 2. `<script>`, `<script async>`, `<script defer>`의 차이점을 설명하세요.
- `<script>`: 스크립트 다운로드와 실행 중 HTML 파싱을 차단. 스크립트는 순서대로 실행
- `<script async>`: HTML 파싱과 병렬로 스크립트 다운로드. 다운로드 완료 즉시 실행하여 파싱을 차단할 수 있음. 실행 순서 보장 안됨
- `<script defer>`: HTML 파싱과 병렬로 스크립트 다운로드. HTML 파싱 완료까지 기다린 후 실행. 스크립트는 순서대로 실행

## 3. JavaScript의 호이스팅 개념을 설명하세요.
컴파일 단계에서 변수와 함수 선언이 포함된 스코프의 맨 위로 이동되는 JS 메커니즘입니다. `var` 선언은 호이스팅되어 `undefined`로 초기화됩니다. 함수 선언은 완전히 호이스팅됩니다. `let`과 `const`는 호이스팅되지만 초기화되지 않습니다(일시적 사각지대).

## 4. `let`, `var`, `const`로 생성된 JavaScript 변수의 차이점은 무엇인가요?
- `var`: 함수 스코프, 호이스팅되어 `undefined`로 초기화, 재선언 가능, 재할당 가능
- `let`: 블록 스코프, 호이스팅되지만 초기화 안됨(일시적 사각지대), 재선언 불가, 재할당 가능
- `const`: 블록 스코프, 호이스팅되지만 초기화 안됨, 재선언 불가, 재할당 불가(하지만 객체/배열은 변경 가능)

## 5. JavaScript의 클로저란 무엇이며, 어떻게 또는 왜 사용하나요?
클로저는 내부 함수가 외부(둘러싸는) 함수의 스코프 변수에 접근할 수 있는 것으로, 외부 함수 실행이 끝난 후에도 가능합니다. 데이터 프라이버시, 함수 팩토리 생성, 모듈 패턴, 비동기 작업에서 상태 유지에 사용됩니다.

## 6. JavaScript와 브라우저에서 이벤트 버블링을 설명하세요.
이벤트 버블링은 자식 요소에서 발생한 이벤트가 부모 요소들을 통해 문서 루트까지 전파되는 것입니다. 이벤트는 대상 요소에서 시작하여 DOM 트리를 통해 "버블링"됩니다. `event.stopPropagation()`으로 중단할 수 있습니다.

## 7. JavaScript의 이벤트 위임을 설명하세요.
이벤트 위임은 여러 자식 요소의 이벤트를 처리하기 위해 부모 요소에 단일 이벤트 리스너를 연결하는 기법입니다. 이벤트 버블링을 활용하여 자식 요소의 이벤트를 포착합니다. 동적 콘텐츠와 성능 최적화에 유용합니다.

## 8. JavaScript 변수 `null`, `undefined`, undeclared의 차이점은 무엇인가요?
- `undefined`: 변수가 선언되었지만 값이 할당되지 않았거나, 함수가 아무것도 반환하지 않음
- `null`: 의도적인 값의 부재, 명시적으로 할당됨
- `undeclared`: 변수가 전혀 선언되지 않음, 접근 시 ReferenceError 발생

## 9. JavaScript의 CommonJS 모듈과 ES 모듈의 차이점을 설명하세요.
- **CommonJS**: `require()`와 `module.exports` 사용, 동기 로딩, 동적 임포트, 주로 Node.js에서 사용
- **ES 모듈**: `import`와 `export` 사용, 비동기 로딩, 정적 분석 가능, 브라우저와 Node.js 지원, 트리 쉐이킹 친화적

## 10. JavaScript 런타임의 이벤트 루프란 무엇인가요?
이벤트 루프는 JavaScript에서 비동기 작업을 처리하는 메커니즘입니다. 콜 스택과 태스크 큐(마이크로태스크와 매크로태스크 큐)를 지속적으로 확인하여 콜 스택이 비어있을 때 태스크를 실행합니다. 마이크로태스크(Promise)가 매크로태스크(setTimeout, DOM 이벤트)보다 높은 우선순위를 가집니다.

## 11. JavaScript에서 콜백 대신 Promise를 사용하는 장단점은 무엇인가요?
**장점**: `.catch()`로 더 나은 에러 처리, 콜백 지옥 방지, `.then()`으로 체이닝 가능, 더 나은 가독성, async/await와 잘 작동
**단점**: 간단한 작업에는 약간 복잡, Promise 상태 이해 필요, 매우 오래된 브라우저에서 지원 안됨

## 12. 블록 포맷팅 컨텍스트(BFC)를 설명하고 어떻게 작동하는지 설명하세요.
블록 포맷팅 컨텍스트(BFC)는 블록 박스가 배치되는 시각적 CSS 렌더링의 일부입니다. BFC를 생성하는 요소에는 플로팅 요소, 절대 위치 요소, `overflow`가 `visible`이 아닌 요소, `display: flow-root`, flex/grid 컨테이너가 있습니다. BFC는 마진 병합을 방지하고 플로팅된 자식을 포함합니다.

## 13. z-index와 쌓임 컨텍스트가 어떻게 형성되는지 설명하세요.
`z-index`는 위치가 지정된 요소의 쌓임 순서를 제어합니다. 쌓임 컨텍스트는 `position`이 `static`이 아니고 `z-index`가 `auto`가 아닌 요소, `opacity`가 1보다 작은 요소, `transform`, `filter`, `will-change`, `z-index`가 있는 flex/grid 아이템에 의해 형성됩니다. 같은 쌓임 컨텍스트 내의 요소들은 `z-index` 값으로 비교됩니다.

## 14. 브라우저가 CSS 선택자와 일치하는 요소를 어떻게 결정하는지 설명하세요.
브라우저는 CSS 선택자를 오른쪽에서 왼쪽으로(가장 오른쪽 선택자부터) 파싱합니다. 키 선택자(가장 오른쪽)로 시작하여 요소를 필터링한 다음, 부모 요소가 나머지 선택자와 일치하는지 확인합니다. 이 방식은 일치하지 않는 요소를 빠르게 제거하므로 더 효율적입니다.

## 15. 박스 모델에 대한 이해와 CSS에서 다른 박스 모델로 렌더링하도록 브라우저에 지시하는 방법을 설명하세요.
CSS 박스 모델은 콘텐츠, 패딩, 보더, 마진으로 구성됩니다. 기본적으로 `width`와 `height`는 콘텐츠에만 적용됩니다(content-box). `box-sizing: border-box`를 사용하면 `width`와 `height`에 패딩과 보더가 포함되어 레이아웃 계산이 쉬워집니다.

## 16. `translate()`를 `absolute` 포지셔닝 대신 사용하거나 그 반대로 사용하는 이유가 있나요?
`translate()`는 애니메이션에 더 좋습니다(하드웨어 가속, 레이아웃/페인트 트리거 안함), 문서 플로우 유지, 더 성능이 좋습니다. `absolute` 포지셔닝은 요소를 문서 플로우에서 제거하므로 오버레이, 툴팁, 또는 위치가 지정된 조상에 상대적인 정확한 위치가 필요할 때 유용합니다.

## 17. `{ box-sizing: border-box; }`는 무엇을 하나요?
박스 모델을 변경하여 `width`와 `height`가 콘텐츠 영역뿐만 아니라 패딩과 보더를 포함하도록 합니다. 패딩과 보더 값에 관계없이 전체 크기가 지정된 너비/높이와 같아지므로 요소 크기를 예측 가능하게 만들기 쉬워집니다.

## 18. CSS `display` 속성이란 무엇이며 사용 예시를 들어주세요.
`display` 속성은 요소가 문서 플로우에서 어떻게 표시되는지 정의합니다. 예시:
- `block`: 전체 너비 차지, 새 줄에서 시작 (div, p)
- `inline`: 필요한 너비만 차지, 줄 바꿈 안함 (span, a)
- `inline-block`: 인라인 동작이지만 너비/높이 가질 수 있음
- `flex`: 유연한 레이아웃 컨테이너 생성
- `grid`: 그리드 레이아웃 컨테이너 생성
- `none`: 요소가 표시되지 않음

## 19. `relative`, `fixed`, `absolute`, `sticky`, `static` 위치 지정 요소의 차이점은 무엇인가요?
- `static`: 기본 위치 지정, 일반 문서 플로우를 따름
- `relative`: 일반 위치에 상대적으로 위치 지정, 문서 플로우에서 공간 유지
- `absolute`: 가장 가까운 위치 지정된 조상에 상대적으로 위치, 문서 플로우에서 제거
- `fixed`: 뷰포트에 상대적으로 위치, 문서 플로우에서 제거, 스크롤 시 제자리 유지
- `sticky`: 스크롤 위치에 따라 relative와 fixed 사이 전환

## 20. 다국어 사이트를 설계하거나 개발할 때 주의해야 할 사항은 무엇인가요?
- 다른 언어에서 텍스트 확장/축소
- 오른쪽에서 왼쪽(RTL) 언어의 다른 레이아웃 요구
- 문자 인코딩 (UTF-8)
- 다른 문자체계의 폰트 지원
- 날짜, 시간, 숫자 형식
- 색상, 이미지, 기호의 문화적 고려사항
- 다른 언어의 URL 구조
- hreflang 태그를 사용한 SEO 고려사항

## 21. `block`, `inline`, `inline-block`의 차이점은 무엇인가요?
- `block`: 사용 가능한 전체 너비 차지, 새 줄에서 시작, 너비/높이/마진/패딩 가능
- `inline`: 콘텐츠 너비만 차지, 줄 바꿈 안함, 너비/높이 무시, 수평 마진/패딩만
- `inline-block`: 인라인 플로우 동작이지만 블록 요소처럼 너비/높이 가능, 모든 마진/패딩 적용

---

# 추가 CSS 문제

## 22. CSS Grid와 Flexbox의 차이점과 각각 언제 사용해야 하는지 설명하세요.
**CSS Grid**: 2차원 레이아웃 시스템(행과 열), 복잡한 레이아웃에 적합, 아이템을 정확한 위치에 배치 가능
**Flexbox**: 1차원 레이아웃 시스템(행 또는 열), 컨테이너 내 아이템 정렬과 분산에 적합, 동적 크기 조정
**사용 시기**: Grid는 전체 페이지 레이아웃, 카드 그리드에, Flexbox는 네비게이션 바, 버튼 그룹, 센터링에 사용

## 23. CSS 변수(Custom Properties)란 무엇이며 어떻게 사용하나요?
CSS에서 재사용 가능한 값을 저장하는 방법입니다. `--`로 시작하여 정의하고 `var()`로 사용합니다.
```css
:root {
  --primary-color: #3498db;
  --font-size: 16px;
}
.button {
  background-color: var(--primary-color);
  font-size: var(--font-size);
}
```
테마 관리, 일관성 유지, 동적 스타일링에 유용합니다.

## 24. CSS의 `em`, `rem`, `px`, `%`, `vh`, `vw` 단위의 차이점을 설명하세요.
- `px`: 절대 단위, 픽셀 기반
- `em`: 부모 요소의 폰트 크기에 상대적
- `rem`: 루트 요소의 폰트 크기에 상대적
- `%`: 부모 요소에 상대적인 백분율
- `vh`: 뷰포트 높이의 1% (1vh = 뷰포트 높이의 1%)
- `vw`: 뷰포트 너비의 1% (1vw = 뷰포트 너비의 1%)

## 25. CSS 애니메이션과 트랜지션의 차이점은 무엇인가요?
**트랜지션**: 속성 변화를 부드럽게 만듦, 트리거 필요(hover, focus 등), 단순한 A에서 B로의 변화
**애니메이션**: 복잡한 키프레임 기반, 자동 실행 가능, 여러 단계 정의 가능, 반복과 방향 제어 가능
```css
/* 트랜지션 */
.box { transition: background-color 0.3s ease; }
/* 애니메이션 */
@keyframes slide { 0% { left: 0; } 100% { left: 100px; } }
.box { animation: slide 2s infinite; }
```

## 26. CSS의 `float` 속성과 관련된 문제점들과 해결 방법을 설명하세요.
**문제점**: 부모 요소가 플로팅된 자식의 높이를 인식하지 못함(높이 붕괴), 다른 요소들이 플로팅 요소 주변으로 흘러감
**해결 방법**: 
- `clearfix` 기법 사용
- 부모에 `overflow: hidden` 적용
- `display: flow-root` 사용 (현대적 방법)
- Flexbox나 Grid 사용 (권장)

## 27. CSS 선택자의 우선순위(specificity) 계산 방법을 설명하세요.
우선순위는 4개 범주로 계산됩니다:
1. 인라인 스타일 (1000점)
2. ID 선택자 (100점)
3. 클래스, 속성, 가상 클래스 (10점)
4. 요소, 가상 요소 (1점)
점수가 높을수록 우선순위가 높습니다. `!important`는 모든 것을 무시합니다.

## 28. CSS의 `overflow` 속성의 다양한 값들과 각각의 동작을 설명하세요.
- `visible`: 기본값, 콘텐츠가 넘쳐도 표시
- `hidden`: 넘치는 콘텐츠 숨김
- `scroll`: 항상 스크롤바 표시
- `auto`: 필요할 때만 스크롤바 표시
- `clip`: hidden과 비슷하지만 프로그래밍 방식 스크롤 금지
- `overlay`: 스크롤바가 콘텐츠 위에 오버레이

## 29. CSS 전처리기(Sass, Less)의 장점과 주요 기능들을 설명하세요.
**장점**: 변수 사용, 중첩 가능, 믹스인으로 재사용, 함수와 연산, 모듈화, 더 나은 구조
**주요 기능**:
- 변수: `$primary-color: #333;`
- 중첩: 선택자 내부에 선택자 작성
- 믹스인: 재사용 가능한 스타일 그룹
- 상속: `@extend`로 스타일 상속
- 함수: 색상 조작, 계산 등

## 30. CSS의 `will-change` 속성은 무엇이며 언제 사용해야 하나요?
브라우저에게 요소가 변경될 것임을 미리 알려주는 속성입니다. 브라우저가 최적화를 준비할 수 있게 합니다.
```css
.element {
  will-change: transform, opacity;
}
```
애니메이션 전에 설정하고 애니메이션 후 `auto`로 재설정해야 합니다. 남용하면 메모리 사용량이 증가할 수 있습니다.

## 31. CSS의 `contain` 속성과 성능 최적화에 미치는 영향을 설명하세요.
브라우저에게 요소의 하위 트리가 나머지 페이지와 독립적임을 알려주는 속성입니다.
- `layout`: 레이아웃 격리
- `paint`: 페인팅 격리  
- `size`: 크기 격리
- `style`: 스타일 격리
성능 향상을 위해 불필요한 재계산을 방지하고 렌더링 최적화에 도움을 줍니다.

## 32. CSS의 논리적 속성(logical properties)이란 무엇이며 왜 사용하나요?
물리적 방향(top, right, bottom, left) 대신 논리적 방향을 사용하는 속성들입니다.
- `margin-inline-start` (왼쪽 또는 오른쪽)
- `margin-block-start` (위쪽)
- `border-inline-end` (오른쪽 또는 왼쪽)
RTL(right-to-left) 언어나 다양한 쓰기 모드를 지원하는 국제화에 유용합니다.

## 33. CSS의 `aspect-ratio` 속성의 사용법과 이점을 설명하세요.
요소의 가로세로 비율을 설정하는 속성입니다.
```css
.video-container {
  aspect-ratio: 16 / 9;
}
.square {
  aspect-ratio: 1;
}
```
반응형 미디어, 카드 레이아웃에서 일관된 비율 유지, 레이아웃 시프트 방지에 유용합니다.

## 34. CSS의 `clamp()`, `min()`, `max()` 함수들의 차이점과 사용 예시를 들어주세요.
- `min()`: 여러 값 중 가장 작은 값 선택
- `max()`: 여러 값 중 가장 큰 값 선택  
- `clamp()`: 최솟값, 기본값, 최댓값을 설정하여 범위 제한
```css
width: min(100%, 500px);     /* 100% 또는 500px 중 작은 값 */
width: max(200px, 50%);      /* 200px 또는 50% 중 큰 값 */
font-size: clamp(1rem, 4vw, 2rem); /* 1rem~2rem 사이에서 4vw */
```

## 35. CSS의 `@supports` 규칙은 무엇이며 어떻게 사용하나요?
브라우저가 특정 CSS 속성이나 값을 지원하는지 확인하는 조건부 규칙입니다.
```css
@supports (display: grid) {
  .container {
    display: grid;
  }
}
@supports not (display: grid) {
  .container {
    display: flex;
  }
}
```
점진적 향상과 브라우저 호환성 처리에 유용합니다. 